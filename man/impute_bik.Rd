% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/impute_bik.R
\name{impute_bik}
\alias{impute_bik}
\title{Imputes \eqn{b_{ik}}}
\usage{
impute_bik(x = list(), eps = 0.001, EPS = 1e-24)
}
\arguments{
\item{x}{a list object obtained from \code{bik_all_2x2()} or \code{bik_all_3x3()}}

\item{eps}{a numeric scalar which is used to determine the imputation value to replace negative or zero values. \cr
For example, with \code{eps = 0.001} and \code{bi1 = c(0.25, -1.0, 0.5)} will replace the \code{-1} value to \code{0.25*0.001 = 0.00025} because \code{0.25} is the minimum value excluding the \code{-1}}

\item{EPS}{a numeric scalar which is used to determine the imputation value in the case when the entire vector is negative or zero.}
}
\value{
a list that has the same structure as the input argument \code{x}, except any negative or zero values are imputed
}
\description{
This function imputes the quantity \eqn{b_{ik}} when calculating the likelihood. It works hand-in-hand with the \code{bik_all_2x2()} and \code{bik_all_3x3()} functions. \cr
During numerical optimization, sometimes the quantity \eqn{b_{ik}} could be evaluated to be a non-positive value (even though it should be greater than or equal to 0).
This function is usually called whenever \eqn{b_{ik}} is to be imputed. \cr
It performs the imputation by finding the minimum value greater than 0, then multiplying it by penalizing factor, \eqn{\epsilon}.
}
\note{
This function should not be called externally in most use cases. it is typically called within the EM algorithm and the initial value generation process.
}
\examples{
# generate data
my_ids = c(1, 1, 1,
           2, 2,
           3, 3, 3)
c1 = c(0, 1, 1.5,
       0, 1,
       0, 2, 5)
c2 = c(1, 2, 2,
       1, 1,
       2, 1, 2)
x1 = c(rep(rnorm(n = 1), 3), rep(rnorm(n = 1), 2), rep(rnorm(n = 1), 3))
x2 = c(rep(1, 3), rep(0, 2), rep(1, 3))
w1 = c(rep(runif(n = 1), 3), rep(runif(n = 1), 2), rep(runif(n = 1), 3))
w2 = c(rep(0, 3), rep(0, 2), rep(1, 3))

# create data frame and matrix objects
my_df = data.frame(
  id = my_ids,
  obsTime = c1, state_at_obsTime = c2,
  x1 = x1, x2 = x2,
  w1 = w1, w2 = w2
)

my_df2 = LCTMC:::fmt_rowwise_trans(data = my_df, type = "2x2")
xmat = as.matrix(my_df2[c("x0", "x1", "x2")])
wmat = unique(my_df2[c("id", "w0", "w1", "w2")])
wmat = as.matrix(wmat[!colnames(wmat) \%in\% c("id")])

# - # - # - # - # - # - # - # - # -

# create theta vector
my_theta = c("alpha0.1" = 1.0, "alpha1.1" = 1.0, "alpha2.1" = 1.0,
             "alpha0.2" = 0.5, "alpha1.2" = 0.2, "alpha2.2" = 0.2,
             "beta0.12_1" = 1.1, "beta1.12_1" = 1.1, "beta2.12_1" = 1.1,
             "beta0.21_1" = 1.5, "beta1.21_1" = 1.5, "beta2.21_1" = 1.5,
             "beta0.12_2" = 1.8, "beta1.12_2" = 1.8, "beta2.12_2" = 1.8,
             "beta0.21_2" = 0.3, "beta1.21_2" = 0.3, "beta2.21_2" = 0.3,
             "beta0.12_3" = 1.4, "beta1.12_3" = 1.4, "beta2.12_3" = 1.4,
             "beta0.21_3" = 0.4, "beta1.21_3" = 0.4, "beta2.21_3" = 0.4)

# use bik_all_2x2()
my_b = LCTMC:::bik_all_2x2(
  theta = my_theta,
  data = my_df2,
  Xmat = xmat,
  Wmat = wmat,
  dt = my_df2$dt,
  P.rs = FALSE,
  K = 3L,
  theta.names = gen_theta_names(K = 3L, type = "2x2", purpose = "bik")
)

# manually create negative and zero values
my_b$bi1[2] = 0
my_b$bi1[3] = -1
my_b$bi3[1:3] = c(0, -1 , 0)

print(my_b)                          # before imputation
my_b = LCTMC:::impute_bik(x = my_b)  # imputes
print(my_b)                          # after imputation
}
