% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.R
\name{predict}
\alias{predict}
\alias{predict.lctmc_2x2}
\alias{predict.lctmc_3x3}
\title{Prediction function for the latent class CTMC model}
\usage{
\method{predict}{lctmc_2x2}(object, ...)

\method{predict}{lctmc_3x3}(object, ...)
}
\arguments{
\item{object}{an object of class "lctmc_2x2" or "lctmc_3x3". Obtained by fitting the latent class CTMC model using the \code{lctmc} functions}

\item{...}{the following argument must be specified as part of \code{...}
\describe{
\item{df_pred}{a data.frame object containing two columns: 'id' and 'obsTime'. \cr
The first is the identifier for each individual and the second is a numeric continuous variable, indicating the future time point that we wish to predict the disease status.
This time variable should be greater than the individual-wise maximum time specified in the \code{df_past} data frame}
\item{df_past}{a data.frame object containing the history of observed disease status. This is used to perform latent clustering as well as predict disease state at a future time point}
\item{param.type}{a character scalar. Either "mle" or "kmeans". \cr
If "mle" then the estimated MLE of the latent class CTMC is used as the parameter for prediction. If "kmeans" then Step 1 of the initial value generation process (K-Means algorithm) is used as the prediction parameters.}
}}
}
\value{
A list object containing two elements:
\itemize{
\item \strong{df_pred.lc} is the predicted latent class classification. The predicted class is the class with the largest probability mass.
\item \strong{df_pred.ds} is the predicted disease status. This should be the same size as the input argument \code{df_pred} with an additional column added for the predicted class at the respective observation time.
}
}
\description{
Input a "lctmc" object and performs two types of prediction via the estimated model: \cr
\enumerate{
\item predicts the latent cluster classification. \cr
\item predicts the disease status at a user specified time
}
}
\note{
In the \code{df_pred} data frame, there should only be one ID per person and "obsTime" must be a future time point relative to the \code{df_past} data frame.
The \code{df_past} data frame should contain the disease history of each person that is to be predicted. \cr
All covariates (x0, x1, x2, w0, w1, w2) should be included as well in the \code{df_past} data frame.
}
\examples{
# load data ---------
data("df_to_predict", package = "LCTMC")
data("model_2x2", package = "LCTMC")

# data creation ---------
  ### disease history ~
   ## get df past
  my_df_past = df_to_predict$`2x2`
  my_df_past = split(x = my_df_past, f = my_df_past$id)

  ### disease history ~
   ## filter out the last observation for each ID number
  my_df_past = lapply(
    X = my_df_past,
    FUN = function(d) {
      d[d$obsTime < max(d$obsTime), ]
    }
  )
  my_df_past = do.call(`rbind`, my_df_past)
  rownames(my_df_past) = NULL


  ### future time point to predict on ~
   ## create data frame
  my_df_predict = df_to_predict$`2x2`[c("id", "obsTime", "state_at_obsTime")]
  my_df_predict = split(x = my_df_predict, f = my_df_predict$id)

  ### future time point to predict on ~
   ## filter out the last observation for each ID number
  my_df_predict = lapply(
    X = my_df_predict,
    FUN = function(d) {
      d[d$obsTime == max(d$obsTime), ]
    }
  )
  my_df_predict.answer = do.call(`rbind`, my_df_predict)
  my_df_predict = my_df_predict.answer[c("id", "obsTime")]
  rownames(my_df_predict.answer) = rownames(my_df_predict) = NULL


# predict --------
  ### run function
  my_predictions = predict(
    object = model_2x2,
    df_past = my_df_past, df_pred = my_df_predict,
    param.type = "mle"
  )


  ### check result ~
  ## disease state
  check_result2 = merge(
    my_predictions$df_pred.ds[c("id", "pred_state")],
    my_df_predict.answer[c("id", "state_at_obsTime")],
    by = "id"
  )
  table(check_result2$state_at_obsTime, check_result2$pred_state)
  mean(check_result2$state_at_obsTime == check_result2$pred_state)


  ### check result ~
   ## latent class
  check_result1 = merge(
    my_predictions$df_pred.lc[c("id", "pred_class")],
    unique(df_to_predict$`2x2`[c("id", "latent_class")]),
    by = "id"
  )
  table(check_result1$pred_class, check_result1$latent_class)
  mean(check_result1$pred_class == check_result1$latent_class)

# --------------------------------------------------------------------------- #
# ## NOTE: #### #### #### #
# ##  * Even though the cross-table shows 0\% accuracy, it is actually 100\%.
# ##  * As latent class's labels are meaningless,
# ##     it only matters if the corresponding transition rates are aligned
# ##     (see `LCTMC::align_MLE_2x2` for more info)
# ##  * the lctmc_2x2() and lctmc_3x3() functions will always
# ##     assign the class with greatest `alpha0` estimate as class 1
# ##     and the class with smallest `alpha0` as the last class, `K`.
# --------------------------------------------------------------------------- #
}
\seealso{
\code{\link[=lctmc_2x2]{lctmc_2x2()}}; \code{\link[=lctmc_3x3]{lctmc_3x3()}}
}
