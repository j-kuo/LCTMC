% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/get_SE_lctmc_2x2.R
\name{get_SE_lctmc_2x2}
\alias{get_SE_lctmc_2x2}
\title{SE Approximation for the Latent CTMC model (2x2)}
\usage{
get_SE_lctmc_2x2(
  em,
  df,
  df.Xmat,
  df.Wmat,
  df.dt,
  par_constraint,
  K,
  solve.tol = (.Machine$double.eps)^2,
  symmetric.tol = 5e-11,
  eigen0.tol = 1e-10,
  MyModelName
)
}
\arguments{
\item{em}{a list object of with custom class 'lctmc_2x2.mle'. This type of object is the output of the function \code{EM_lctmc_2x2()}}

\item{df}{a data frame object containing the binary row-wise transition indicator variables (usually obtained from \code{fmt_rowwise_2x2trans()})}

\item{df.Xmat}{a matrix object with same number of rows as \code{df}. This matrix object should contain the covariates which affect the CTMC part of the model}

\item{df.Wmat}{a matrix object with number of rows equal to the unique number of individuals in \code{df}.
This matrix object should contain the covariates which affect the latent class probability part of the model.}

\item{df.dt}{a numeric vector with length equal to the number of rows as \code{df}. This vector contains the time difference between observations.}

\item{par_constraint}{a named numeric vector to indicate which parameter is constrained. Set equal to NULL for unconstrained model. \cr
For example, \code{c(alpha1.1 = 0)} constraints the parameter 'alpha1.1' to be a constant 0. \strong{NOTE:} Current version of the code will \emph{only} work with constrains equal to 0.}

\item{K}{the number of categories the latent class variable has.}

\item{solve.tol}{a numeric scalar, typically a small decimal value. It is the tolerance for detecting linear dependencies in the hessian matrix. Defaults to \code{(.Machine$double.eps)^2} if not specified.}

\item{symmetric.tol}{a numeric scalar. Tolerane value for checking symmetric matrix. \cr Default is 5e-11}

\item{eigen0.tol}{a numeric scalar. Tolerance value for eigenvalues, any values smaller than this will be treated as 0. \cr Default is 1e-10}

\item{MyModelName}{a character scalar. Gives the current model fitting process a name. This name will be used when the function is logging the algorithm progress.}
}
\value{
a list object containing 3 elements:
\itemize{
\item \code{SE} is a data frame object containing columns for: the MLE, the approximated SE, and the 95\% confidence interval for the MLE
\item \code{covariance_code} a numeric scalar that can take be one of three values. \cr
0: when the covariance matrix is neither positive definite or semi positive definite \cr
1: when the covariance matrix is semi positive definite \cr
2: when the covariance matrix is positive definite
\item \code{hess_code} similar to \code{covariance_code} \cr
0: when the hessian is neither negative definite or semi negative definite (saddle point) \cr
1: when the covariance matrix is semi positive definite (inconclusive result) \cr
2: when the covariance matrix is positive definite (a local optimal point)
\item \code{Covariance} a matrix object which is the estimated variance covariance matrix for the estimated parameters. \cr
Note that the estimated SE is simply square root of the diagonal elements.
}
}
\description{
Uses the large sample approximation for to estimate the standard error of the MLE (see \strong{Note} for more info). \cr
The result of the approximation is the variance-covariance matrix for the vector of the estimated MLE, where the diagonal elements are the variance and off-diagonals are the covariance.
}
\note{
This function uses the large sample theory
\deqn{
  \hat\theta \sim N(\theta, -H^{-1}(\hat\theta))
}
where, \eqn{H(\hat\theta)} is the hessian of the observed log likelihood function evaluated at the MLE. And \eqn{\hat\theta} is the estimated MLE.
Since this SE approximation relies on large sample, user should be cautious when considering sample size and number of model parameters.
}
\examples{
## TO BE ADDED ##
}
