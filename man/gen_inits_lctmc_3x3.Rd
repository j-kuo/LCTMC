% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen_inits_lctmc_3x3.R
\name{gen_inits_lctmc_3x3}
\alias{gen_inits_lctmc_3x3}
\title{Generates initial value for model fitting}
\usage{
gen_inits_lctmc_3x3(
  df,
  Xmat,
  Wmat,
  dt,
  K,
  N_sub,
  pct_keep,
  par_constraint,
  returns = 2L,
  parallelize,
  which_step1,
  parallel_optim,
  MyModelName
)
}
\arguments{
\item{df}{a data frame object containing row-wise transition data as binary variables. \cr
For example, if \code{trans.2_1} equals 1 then it means the observation was a transition from stage 2 to stage 1 within \code{dt} amount of time.}

\item{Xmat}{a matrix object housing the covariates that affect the CTMC portion of the model. \cr
This matrix should have the same number of rows as the data frame object, \code{data}}

\item{Wmat}{a matrix object housing the covariates that affect the latent classification part of the model. \cr
This matrix should have number of rows equal to unique number of individuals in the data frame object, \code{data}}

\item{dt}{a numeric vector housing the length of time interval between observations. This vector's length should be equal to number of rows in the data frame object, \code{data}}

\item{K}{the number of categories the latent class variable has}

\item{N_sub}{a numeric scalar. This is used for Step 1 of initial value generation where the algorithm fits the traditional CTMC model for each individual. \cr
Fitting the model for \emph{all} individuals might have long run time without improvement in the accuracy of the estimation. Thus, setting a maximum number of individuals to use for the initial value generation could shorten run without sacrificing in estimation accuracy.}

\item{pct_keep}{a numeric vector where each element of the vector ranges from 0 to 1 (ideally at minimum 0.50). \cr
This argument controls what percentage of the individual level estimated effects to be used for the K-means algorithm for initial value generation.
For example, for pct_keep = c(0.8), after individuals effects are estimated, only the 10th to 90th percentile are used for the K-Means algorithm to obtain cluster level estimates.}

\item{par_constraint}{a named numeric vector to indicate which parameter is constrained. Set equal to NULL for unconstrained model. \cr
For example, \code{c(alpha1.1 = 0)} constraints the parameter 'alpha1.1' to be a constant 0. \strong{NOTE:} Current version of the code will \emph{only} work with constrains equal to 0.}

\item{returns}{an integer scalar, either 1L or 2L. Other values will cause function to return NULL values. \cr
This argument determines if the function should return only the Step 1 estimates (\code{returns = 1L}) or both steps (\code{returns = 2L})}

\item{parallelize}{a logical scalar. Set to TRUE if we want the for-loop for the individual-wise CTMC to be parallelized}

\item{which_step1}{a character scalar. Either "100\%" or "best". The former will use 100\% of the individual CTCM effects to perform the K-means algorithm. \cr
The latter will compute the \eqn{log(P(Y))} value for all possible K-means result and use the thetas that yields the largest \eqn{log(P(Y))}.}

\item{parallel_optim}{a list object telling the function whether parallel process should be used for the Step 2 of the initial value generation. \cr
The list should contain \strong{two} elements: \cr
(1) \code{run} a logical scalar, if TRUE then this function will use parallel processing. If FALSE, then the \code{cl} argument is ignored. \cr
(2) \code{cl} is an object obtained from the \code{parallel} package, for example \cr \code{cl = parallel::makeCluster(spec = 2)}}

\item{MyModelName}{a character scalar. Gives the current model fitting process a name. This name will be used when the function is logging the algorithm progress.}
}
\value{
A list containing the estimates obtained from step1 (K-means) or both steps (K-Means + direct optimization on observed data likelihood). \cr\cr
Step 1 of the algorithm outputs 3 elements:
\itemize{
\item \strong{step1} - a list of possible initial values, each element is the result of the K-means algorithm by trimming the individual estimate by the \code{pct_keep} argument
\item \strong{step1_full} - a single named numeric vector from the K-means using 100\% of individual estimates (no trimming outliers, when \code{pct_keep = 1})
\item \strong{step1_best} - a single named numeric vector that yielded the best observed log-likelihood value by testing trying each vector from \code{step1}
}
Step 2 of the algorithm outputs a named numeric vector obtained by maximizing the observed log-likelihood function (see \strong{Note} section). This step is only performed is the argument \code{returns} is set to \code{2L}
}
\description{
This function generates initial value for the Latent Class CTMC model (special 3x3 case). This is a two-step process, where we first use the K-means algorithm on the individuals' effect to create cluster level estimates.
Then, in the second step, a direct optimization on the observed data likelihood using Step 1's estimate is performed to obtain a set of improved initial values.
The output of this function should then be fed to the EM algorithm to obtain a tighter Maximum Likelihood Estimate.
}
\note{
Step 1 is an individual level fitting algorithm and then uses K-means algorithm to perform clustering based on the individuals' effects
Step2 is equivalent to obtaining the MLE. It performs numerical optimization on the observed log-likelihood function:
\deqn{
  P(Y) = \sum_{i} log(P(Y_{i}))
}
where
\deqn{
  P(Y_{i}) = \sum_{k} P(Y_{i}=y_{i} \cap Z_{i}=k)
}
and the summand could be simplified via Bayes' Theorem:
\deqn{
  P(Y_{i} \cap Z_{i}) = P(Z_{i}) \cdot P(Y_{i} | Z_{i})
}
}
\examples{
## TO BE ADDED ##
}
