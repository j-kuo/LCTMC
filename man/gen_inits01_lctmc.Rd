% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen_inits01_lctmc.R
\name{gen_inits01_lctmc}
\alias{gen_inits01_lctmc}
\alias{gen_inits01_lctmc_2x2}
\alias{gen_inits01_lctmc_3x3}
\title{Step 1/2 for generating initial value for model fitting}
\usage{
gen_inits01_lctmc_2x2(
  df,
  df_Xmat,
  df_Wmat,
  df_dt,
  K,
  par_constraint,
  N_sub,
  pct_keep,
  parallelize,
  parallel_optim
)

gen_inits01_lctmc_3x3(
  df,
  df_Xmat,
  df_Wmat,
  df_dt,
  K,
  par_constraint,
  N_sub,
  pct_keep,
  parallelize,
  parallel_optim
)
}
\arguments{
\item{df}{a data frame object containing row-wise transition data as binary variables. \cr
For example, if \code{trans.2_1} equals 1 then it means the observation was a transition from stage 2 to stage 1 within \code{df_dt} amount of time.}

\item{df_Xmat}{a matrix object housing the covariates that affect the CTMC portion of the model. \cr
This matrix should have the same number of rows as the data frame object, \code{df}}

\item{df_Wmat}{a matrix object housing the covariates that affect the latent classification part of the model. \cr
This matrix should have number of rows equal to unique number of individuals in the data frame object, \code{df}}

\item{df_dt}{a numeric vector housing the length of time interval between observations.
This vector's length should be equal to number of rows in the data frame object, \code{df}}

\item{K}{an integer scalar. Use this variable to tell the function how many latent classes there should be. \cr}

\item{par_constraint}{See documentation in \code{\link[=lctmc_2x2]{lctmc_2x2()}} or \code{\link[=lctmc_3x3]{lctmc_3x3()}}}

\item{N_sub}{See documentation in \code{\link[=lctmc_2x2]{lctmc_2x2()}} or \code{\link[=lctmc_3x3]{lctmc_3x3()}}}

\item{pct_keep}{See documentation in \code{\link[=lctmc_2x2]{lctmc_2x2()}} or \code{\link[=lctmc_3x3]{lctmc_3x3()}}}

\item{parallelize}{See documentation in \code{\link[=lctmc_2x2]{lctmc_2x2()}} or \code{\link[=lctmc_3x3]{lctmc_3x3()}}}

\item{parallel_optim}{See documentation in \code{\link[=lctmc_2x2]{lctmc_2x2()}} or \code{\link[=lctmc_3x3]{lctmc_3x3()}}}
}
\value{
A list containing the estimates obtained from the K-means algorithm.
This step outputs 3 elements:
\itemize{
\item \strong{step1_full} - a list object containing the estimation from using 100\% of individual effects (no trimming outliers, when \code{pct_keep = 1}). \cr
First is the the theta estimates, and second is a 'kmeans' object from \code{kmeans()}.
\item \strong{step1_best} - a single named numeric vector that yielded the best observed log-likelihood value by testing trying each vector from \code{step1}
}
}
\description{
Performs step 1 of the initial value generation. This is a two-stage k-means procedure, where stage 1 involves fitting a
traditional CTMC model to each individual in the \code{df} data frame. Then the individual effects are pooled and fed into a k-means algorithm to split
the estimate into \code{K} clusters.
}
\note{
This is the second step out of six of fitting a latent class CTMC model (i.e., generate initial values via a two stage k-means algorithm). \cr\cr
This is also part 1 of initial value generation,
which is an individual level fitting algorithm and then uses K-means method to perform clustering based on the individuals' effects. \cr
If using This method alone to model the data, it will very likely perform poorly.
Especially when there are only few observation per person, it becomes reliable when each individual has many observations. \cr
Regardless, this approach will still produce usable initial values for the next steps.
}
\examples{
# The example below demonstrates how to specify the 'lctmc' functions correctly
#   to perform the latent class CTMC model.
# Both the 2x2 and 3x3 examples are listed below, however it should be noted
#   that the model may take a while to run (approx. 10-30min on a high spec laptop)
# In both examples, we set the number of latent classes, K, to be 3.
# in the 2x2 model, we constrained the model so that the covariate effects on
#   the latent class probability are equal to 0.
# in the 3x3 model, we left the model un-constrained.


\dontrun{
  ## this is a 2x2 example, with 3 latent classes
  data("example_df2x2", package = "LCTMC")
  model_2x2 = LCTMC::lctmc_2x2(
    # data
    data = example_df2x2,
    # any scaling transformation
    dt_scale = c(dt = 1/365),
    x_scale = c(x0 = 1, x1 = 1/7, x2 = 1),
    w_scale = c(w0 = 1, w1 = 1/9, w2 = 1),
    # general model specification
    K = 3L,
    X_names = c('x0', 'x1', 'x2'),
    W_names = c('w0', 'w1', 'w2'),
    par_constraint = c(alpha1.1 = 0, alpha1.2 = 0, alpha2.1 = 0, alpha2.2 = 0),
    # controls ~ gen_inits
    N_sub = Inf,
    pct_keep = seq(0.40, 1.00, 0.001),
    parallelize = TRUE,
    which_step1 = "best",
    # controls ~ EM
    theta.names = LCTMC::gen_theta_names(K = 3L, type = "2x2", purpose = "em"),
    EM_controls = list(maxit = 50, ELL_tol = 1e-1, LPY_tol = 1e-3, par_tol = 1e-3),
    optim_controls = list(fnscale = -nrow(example_df2x2), maxit = 1e8, factr = 1e-4),
    # misc.
    test_if_global_optim = list(test = FALSE, true_params = NA),
    parallel_optim = list(run = TRUE, cl = parallel::makeCluster(spec = parallel::detectCores()-1)),
    MyModelName = "My 2x2 (K3) Model"
  )

  # - # - # - # - # - # - # - # - #

  ## this is a 3x3 example, with 3 latent classes
  data("example_df3x3", package = "LCTMC")
  model_3x3 = LCTMC::lctmc_3x3(
    # data
    data = example_df3x3,
    # any scaling transformation
    dt_scale = c(dt = 1/365),
    x_scale = c(x0 = 1, x1 = 1/8, x2 = 1),
    w_scale = c(w0 = 1, w1 = 1/8, w2 = 1),
    # general model specification
    K = 3L,
    X_names = c('x0', 'x1', 'x2'),
    W_names = c('w0', 'w1', 'w2'),
    par_constraint = NULL,
    # controls ~ gen_inits
    N_sub = Inf,
    pct_keep = seq(0.40, 1.00, 0.001),
    parallelize = TRUE,
    which_step1 = "best",
    # controls ~ EM
    theta.names = LCTMC::gen_theta_names(K = 3L, type = "3x3", purpose = "em"),
    EM_controls = list(maxit = 50, ELL_tol = 1e-1, LPY_tol = 1e-3, par_tol = 1e-3),
    optim_controls = list(fnscale = -nrow(example_df3x3), maxit = 1e8, factr = 1e-4),
    # misc.
    test_if_global_optim = list(test = FALSE, true_params = NA),
    parallel_optim = list(run = TRUE, cl = parallel::makeCluster(spec = parallel::detectCores()-1)),
    MyModelName = "My 3x3 (K3) Model"
  )
}
}
\seealso{
\code{\link[=lctmc_2x2]{lctmc_2x2()}}; \code{\link[=fmt_rowwise_trans]{fmt_rowwise_trans()}}; \code{\link[=gen_inits02_lctmc_2x2]{gen_inits02_lctmc_2x2()}}; \code{\link[=indiv_ctmc_2x2]{indiv_ctmc_2x2()}}
}
