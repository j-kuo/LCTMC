% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lctmc.R
\name{lctmc}
\alias{lctmc}
\alias{lctmc_2x2}
\alias{lctmc_3x3}
\title{Fit a Latent Class CTMC model}
\usage{
lctmc_2x2(
  data = data.frame(),
  X_names = c(),
  W_names = c(),
  x_scale = c(),
  w_scale = c(),
  dt_scale = c(),
  K = integer(),
  par_constraint,
  N_sub,
  pct_keep = c(),
  parallelize = FALSE,
  which_step1 = c("100\%", "best"),
  theta.names = list(),
  EM_controls = list(),
  optim_controls = list(),
  parallel_optim = list(run = FALSE, cl = NA),
  MyModelName = "lctmc_2x2"
)

lctmc_3x3(
  data = data.frame(),
  X_names = c(),
  W_names = c(),
  x_scale = c(),
  w_scale = c(),
  dt_scale = c(),
  K = integer(),
  par_constraint,
  N_sub,
  pct_keep = c(),
  parallelize = FALSE,
  which_step1 = c("100\%", "best"),
  theta.names = list(),
  EM_controls = list(),
  optim_controls = list(),
  parallel_optim = list(run = FALSE, cl = NA),
  MyModelName = "lctmc_3x3"
)
}
\arguments{
\item{data}{a data frame object with data stored in long-format}

\item{X_names}{a named character vector. Hosting the names of covariates for the CTMC model. It should be a column in \code{data}. \cr
Best set to x0, x1, x2 to avoid errors}

\item{W_names}{a named character vector. Hosting names of covariates for the latent class component. It should be a column in \code{data}. \cr
Best set to w0, w1, w2 to avoid errors}

\item{x_scale}{a named numeric vector. It is a scaling parameters for covariates that affect the CTMC process. \cr
For example, \code{x_scale = c(x0 = 1, x1 = 1/5, x2 = 1)} would convert x1 from 10 to 2.}

\item{w_scale}{a named numeric vector. It is a scaling parameters for covariates that affect the latent class component of the model  \cr
For example, \code{w_scale = c(w0 = 1, x1 = 1/3, x2 = 1)} would convert w1 from 12 to 4.}

\item{dt_scale}{a named numeric scalar. It is a scaling parameter for observation time intervals. \cr
For example, \code{dt_scale = c(dt = 1/10)} would converts a time unit from 10 to 1.}

\item{K}{an integer scalar. Use this variable to tell the function how many latent classes there should be. \cr
Note that the number of latent classes will affect the number of parameters in the model, thus the argument \code{theta.name} should be in sync with \code{K}}

\item{par_constraint}{a named numeric vector to indicate which parameter is constrained. Set equal to NULL for unconstrained model. \cr
For example, \code{c(alpha1.1 = 0)} constraints the parameter 'alpha1.1' to be a constant 0. \strong{NOTE:} Current version of the code will \emph{only} work with constrains equal to 0.}

\item{N_sub}{a numeric scalar. This is used for step 1 of initial value generation where the algorithm fits a traditional CTMC model for each individual. \cr
Fitting the model for \emph{all} individuals might have long run time without improvement in the accuracy of the estimation.
Thus, using this argument to set a maximum number of individuals to use for the initial value generation could save some computation time.}

\item{pct_keep}{a numeric vector where each element of the vector ranges from 0 to 1.
This argument controls what percentage of the individual effect should be used for the K-means algorithm for initial value generation.
The algorithm will consider all percentages specified in this vector. \cr
For example, for \code{pct_keep = c(0.5)}, after individuals effects are estimated, only the 25th to 75th percentile are fed into the K-Means algorithm to obtain cluster level estimates. \cr
Additionally, note that the threshold "1" is always appended to \code{pct_keep}, so it will always consider the 100\% case.}

\item{parallelize}{a logical scalar. Set to TRUE if we want the for-loop for the individual-wise CTMC to be parallelized}

\item{which_step1}{a character scalar. Either "100\%" or "best". The former will use 100\% of the individual CTCM effects to perform the K-means algorithm. \cr
The latter will compute the \eqn{log(P(Y))} value for all possible K-means result and use the thetas that yields the largest \eqn{log(P(Y))}.}

\item{theta.names}{See documentation in \code{\link[=lctmc_2x2]{lctmc_2x2()}} or \code{\link[=lctmc_3x3]{lctmc_3x3()}}}

\item{EM_controls}{a list object holding the arguments to tune the EM algorithm.
The following elements are necessary for running the algorithm: \cr
(1) \code{maxit} a numeric scalar. This specifies the max number of EM iterations \cr
(2) \code{ELL_tol} a numeric scalar. This is the tolerance of the conditional expected log likelihood \cr
(3) \code{LPY_tol} a numeric scalar. This is the tolerance of observed log likelihood, \eqn{log(P(Y))} \cr
(4) \code{par_tol} a numeric scalar. This is the tolerance of parameter changes per EM iteration \cr \cr
Note that for all 3 tolerance parameters, the smaller the value, the more accurate the estimate will be. But it will also lead to longer computation time.}

\item{optim_controls}{a list object holding the arguments to control the L-BFGS optimization at each ECM step.
The following elements are necessary for running the algorithm: \cr
(1) \code{fnscale} a numeric scalar. This value scales the objective function. Additionally, its sign determines whether the algorithm is performing a maximization or minimization task. \cr
(2) \code{maxit} a numeric scalar. This value specifies the max number of L-BFGS iterations. \cr
(3) \code{factr} a numeric scalar. This value controls the tolerance of L-BFGS optimization. The smaller in magnitude this argument is the more precise the optimization algorithm will be.}

\item{parallel_optim}{a list object telling the function whether parallel process should be used. \cr
The list should contain \strong{two} elements: \cr
(1) \code{run} a logical scalar, if TRUE then this function will use parallel processing. If FALSE, then the \code{cl} argument is ignored. \cr
(2) \code{cl} is an object obtained from the \code{parallel} package, for example \cr \code{cl = parallel::makeCluster(spec = 2)}}

\item{MyModelName}{a character scalar. Gives the current model fitting process a name. This name will be used when the function is logging the algorithm progress.}
}
\value{
A list object containing the following elements:
\itemize{
\item \strong{init01} a list object obtained from the \code{gen_inits01_lctmc} functions
\item \strong{init02} a named numeric vector obtained from the \code{gen_inits02_lctmc} functions
\item \strong{EM} a list object obtained from the \code{EM_lctmc} functions
\item \strong{SE} a list object obtained from the \code{get_SE_lctmc} functions
\item \strong{K} an integer scalar that is identical to the input argument, \code{K}.
\item \strong{n_pars} an integer scalar that indicates the number of parameters estimated
(total number of parameter minus number of constrained parameters).
\item \strong{X_names} a character vector equivalent to the input argument \code{X_names}
\item \strong{W_names} a character vector equivalent to the input argument \code{W_names}
\item \strong{run_time} a "difftime" object. Indicating the total algorithm run time.
}
}
\description{
Fits a latent class CTMC where we assume the data generating process is a CTMC when conditioned on a un-observed latent variable.
}
\note{
The model fitting process essentially breaks down into the following steps:
\enumerate{
\item data processing, formatting, scaling
\item generate initial values step 1, individualized fitting
\item generate initial values step 2, optimization on \eqn{log(P(Y))}
\item EM algorithm to obtain tighter estimate
\item hessian approximation for SE
\item re-scale parameters back to original scale
}
}
\examples{
# The example below demonstrates how to specify the 'lctmc' functions correctly
#   to perform the latent class CTMC model.
# Both the 2x2 and 3x3 examples are listed below, however it should be noted
#   that the models may take a while to run (approx. 10-30min on a high spec laptop)
# In both examples, we set the number of latent classes, K, to be 2.
# In the 2x2 model, we constrained the model so that the covariate effects on
#   the latent class probability are equal to 0.
# In the 3x3 model, we left the model un-constrained.


\dontrun{
  ## this is a 2x2 example, with 3 latent classes
  data("example_df2x2", package = "LCTMC")
  model_2x2 = LCTMC::lctmc_2x2(
    # data
    data = example_df2x2,
    # any scaling transformation
    dt_scale = c(dt = 1/365),
    x_scale = c(x0 = 1, x1 = 1/7, x2 = 1),
    w_scale = c(w0 = 1, w1 = 1/9, w2 = 1),
    # general model specification
    K = 2L,
    X_names = c('x0', 'x1', 'x2'),
    W_names = c('w0', 'w1', 'w2'),
    par_constraint = c(alpha1.1 = 0, alpha2.1 = 0),
    # controls ~ gen_inits
    N_sub = Inf,
    pct_keep = seq(0.40, 1.00, 0.001),
    parallelize = TRUE,
    which_step1 = "best",
    # controls ~ EM
    theta.names = LCTMC::gen_theta_names(K = 2L, type = "2x2", purpose = "em"),
    EM_controls = list(maxit = 50, ELL_tol = 1e-1, LPY_tol = 1e-3, par_tol = 1e-3),
    optim_controls = list(fnscale = -nrow(example_df2x2), maxit = 1e8, factr = 1e-4),
    # misc.
    test_if_global_optim = list(test = FALSE, true_params = NA),
    parallel_optim = list(run = TRUE, cl = parallel::makeCluster(spec = parallel::detectCores()-1)),
    MyModelName = "My 2x2 (K2) Model"
  )

  # - # - # - # - # - # - # - # - #

  ## this is a 3x3 example, with 3 latent classes
  data("example_df3x3", package = "LCTMC")
  model_3x3 = LCTMC::lctmc_3x3(
    # data
    data = example_df3x3,
    # any scaling transformation
    dt_scale = c(dt = 1/365),
    x_scale = c(x0 = 1, x1 = 1/8, x2 = 1),
    w_scale = c(w0 = 1, w1 = 1/8, w2 = 1),
    # general model specification
    K = 2L,
    X_names = c('x0', 'x1', 'x2'),
    W_names = c('w0', 'w1', 'w2'),
    par_constraint = NULL,
    # controls ~ gen_inits
    N_sub = Inf,
    pct_keep = seq(0.40, 1.00, 0.001),
    parallelize = TRUE,
    which_step1 = "best",
    # controls ~ EM
    theta.names = LCTMC::gen_theta_names(K = 2L, type = "3x3", purpose = "em"),
    EM_controls = list(maxit = 50, ELL_tol = 1e-1, LPY_tol = 1e-3, par_tol = 1e-3),
    optim_controls = list(fnscale = -nrow(example_df3x3), maxit = 1e8, factr = 1e-4),
    # misc.
    test_if_global_optim = list(test = FALSE, true_params = NA),
    parallel_optim = list(run = TRUE, cl = parallel::makeCluster(spec = parallel::detectCores()-1)),
    MyModelName = "My 3x3 (K2) Model"
  )
}
}
\seealso{
\code{\link[=fmt_rowwise_trans]{fmt_rowwise_trans()}}; \code{\link[=gen_inits01_lctmc_2x2]{gen_inits01_lctmc_2x2()}}; \code{\link[=gen_inits02_lctmc_2x2]{gen_inits02_lctmc_2x2()}}; \code{\link[=EM_lctmc_2x2]{EM_lctmc_2x2()}}; \code{\link[=get_SE_lctmc_2x2]{get_SE_lctmc_2x2()}}; \code{\link[=rescale_theta]{rescale_theta()}}
}
