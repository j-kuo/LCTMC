% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gen_inits02_lctmc.R
\name{gen_inits02_lctmc}
\alias{gen_inits02_lctmc}
\alias{gen_inits02_lctmc_2x2}
\alias{gen_inits02_lctmc_3x3}
\title{Step 2/2 for generating initial value for model fitting}
\usage{
gen_inits02_lctmc_2x2(
  step2_inits,
  df,
  df_Xmat,
  df_Wmat,
  df_dt,
  K,
  par_constraint,
  parallel_optim
)

gen_inits02_lctmc_3x3(
  step2_inits,
  df,
  df_Xmat,
  df_Wmat,
  df_dt,
  K,
  par_constraint,
  parallel_optim
)
}
\arguments{
\item{step2_inits}{a named numeric vector. This should be a vector of model parameters. \cr
The names of the vector should be parameters names and the values are the initial value for direct likelihood optimization}

\item{df}{a data frame object containing row-wise transition data as binary variables. \cr
For example, if \code{trans.2_1} equals 1 then it means the observation was a transition from stage 2 to stage 1 within \code{df_dt} amount of time.}

\item{df_Xmat}{a matrix object housing the covariates that affect the CTMC portion of the model. \cr
This matrix should have the same number of rows as the data frame object, \code{df}}

\item{df_Wmat}{a matrix object housing the covariates that affect the latent classification part of the model. \cr
This matrix should have number of rows equal to unique number of individuals in the data frame object, \code{df}}

\item{df_dt}{a numeric vector housing the length of time interval between observations.
This vector's length should be equal to number of rows in the data frame object, \code{df}}

\item{K}{an integer scalar. Use this variable to tell the function how many latent classes there should be. \cr}

\item{par_constraint}{See documentation in \code{\link[=lctmc_2x2]{lctmc_2x2()}} or \code{\link[=lctmc_3x3]{lctmc_3x3()}}}

\item{parallel_optim}{See documentation in \code{\link[=lctmc_2x2]{lctmc_2x2()}} or \code{\link[=lctmc_3x3]{lctmc_3x3()}}}
}
\value{
a named numeric vector. This is the vector of model parameters that maximizes the observed data log-likelihood function (see \strong{Note} section).
}
\description{
Performs step 2 of the initial value generation. This is a direct optimization on the observed data likelihood function.
We condition on the number of latent clusters and sum over joint probability between the observed data and the unobserved data. \cr
That is,
\deqn{
  P(Y_{i}) = \sum_{k=1}^{K} P(Y_{i} \cap Z_{i}=k)
}
See \strong{Note} section for more info.
}
\note{
This is the third step out of six of fitting a latent class CTMC model (i.e., generate initial values via direct optimization). \cr\cr
This step is equivalent to obtaining the MLE. It performs numerical optimization on the observed data log likelihood function:
\deqn{
  log(P(Y)) = \sum_{i} log(P(Y_{i}))
}
where
\deqn{
  P(Y_{i}) = \sum_{k} P(Y_{i}=y_{i} \cap Z_{i}=k)
}
and the summand could be simplified as:
\deqn{
  P(Y_{i} \cap Z_{i}) = P(Z_{i}) \cdot P(Y_{i} | Z_{i})
}
}
\examples{
# The example below demonstrates how to specify the 'lctmc' functions correctly
#   to perform the latent class CTMC model.
# -------------------------------------------------------------------------------------
# Both the 2x2 and 3x3 examples are listed below, however it should be noted
#   that the models may take a while to run (approx. 10-30min on a high spec laptop)
# -------------------------------------------------------------------------------------
# In the 2x2 model, we constrained the model so that the covariate effects on
#   the latent class probability are equal to 0.
# -------------------------------------------------------------------------------------
# In the 3x3 model, we left the model un-constrained.
# -------------------------------------------------------------------------------------
# In this code, we also use a for-loop to fit models with 2, 3, and 4 latent classes
#   the actual number of latent classes within these data sets is 2.
# -------------------------------------------------------------------------------------
# The model with the smallest BIC is the "best" model.
# -------------------------------------------------------------------------------------

\dontrun{
  ## this is a 2x2 example, with 3 latent classes
  data("example_df2x2", package = "LCTMC")
  ctrl_2x2 = LCTMC::create_controls(type = "2x2", data = example_df2x2)

  m2x2_list = list()
  for (k in 2:4) {
    m2x2 = LCTMC::lctmc_2x2(
      # data
      data = example_df2x2,
      # general model specification
      K = k,
      X_names = c('x0', 'x1', 'x2'),
      W_names = c('w0', 'w1', 'w2'),
      par_constraint = c(alpha1.1 = 0, alpha2.1 = 0),
      # misc.
      controls = ctrl_2x2,
      parallel_optim = list(
        run = TRUE, cl = parallel::makeCluster(spec = parallel::detectCores()-1)
      ),
      MyModelName = paste("My 2x2 (K=", k, ") model", sep = "")
    )

    m2x2_list[[paste("k=", k, sep = "")]] = m2x2
  }

  names(m2x2_list) = paste("k=", 1:4, sep = "")
  BIC = sapply(
    X = m2x2_list[-1],
    FUN = function(x) {
      log_like = LCTMC::test_global_optim(m = x, data = example_df2x2)$L_mle
      k = x$n_pars
      n = nrow(example_df2x2) - length(unique(example_df2x2$id))
      -2*log_like + k*log(n)
    }
  )
  BIC
  which.min(BIC)


  # - # - # - # - # - # - # - # - #


  ## this is a 3x3 example, with 3 latent classes
  data("example_df3x3", package = "LCTMC")
  ctrl_3x3 = LCTMC::create_controls(type = "3x3", data = example_df3x3)

  m3x3_list = list()
  for (k in 2:4) {
    m3x3 = LCTMC::lctmc_3x3(
      # data
      data = example_df3x3,
      # general model specification
      K = k,
      X_names = c('x0', 'x1', 'x2'),
      W_names = c('w0', 'w1', 'w2'),
      par_constraint = NULL,
      # misc.
      controls = ctrl_3x3,
      parallel_optim = list(
        run = T,
        cl = parallel::makeCluster(spec = parallel::detectCores()-1)
      ),
      MyModelName = paste("My 3x3 (K=", k, ") model", sep = "")
    )

    m3x3_list[[k]] = m3x3
  }

  names(m3x3_list) = paste("k=", 1:4, sep = "")
  BIC = sapply(
    X = m3x3_list[-1],
    FUN = function(x) {
      log_like = LCTMC::test_global_optim(m = x, data = example_df3x3)$L_mle
      k = x$n_pars
      n = nrow(example_df3x3) - length(unique(example_df3x3$id))
      -2*log_like + k*log(n)
    }
  )
  BIC
  which.min(BIC)
}
}
\seealso{
\code{\link[=lctmc_2x2]{lctmc_2x2()}}; \code{\link[=gen_inits01_lctmc_2x2]{gen_inits01_lctmc_2x2()}}; \code{\link[=EM_lctmc_2x2]{EM_lctmc_2x2()}}
}
