% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bik_all.R
\name{bik_all}
\alias{bik_all}
\alias{bik_all_2x2}
\alias{bik_all_3x3}
\title{Computes the quantity \eqn{b_{ik}}}
\usage{
bik_all_2x2(
  theta = c(),
  data = data.frame(),
  Xmat = matrix(),
  Wmat = matrix(),
  dt = c(),
  K,
  P.rs = FALSE,
  theta.names
)

bik_all_3x3(
  theta = c(),
  data = data.frame(),
  Xmat = matrix(),
  Wmat = matrix(),
  dt = c(),
  K,
  P.rs = FALSE,
  theta.names
)
}
\arguments{
\item{theta}{a named vector of numeric values for the model parameters}

\item{data}{a data frame object containing the binary transition indicator variables, i.e., \code{trans.1_1}, \code{trans.1_2}, etc.}

\item{Xmat}{a matrix object containing covariates "X" which are the covariates for the CTMC model}

\item{Wmat}{a matrix object containing covariates "W" which are the covariates for the latent class component of the model}

\item{dt}{a vector of numeric values for the time interval between observations}

\item{K}{a integer scalar. Use this variable to tell the function how many latent classes there should be, The number of latent classes will affect the number of parameter in the model.}

\item{P.rs}{a logical scalar. If TRUE, then \eqn{P_{rs(k)}} is returned as a list object where each element of the list varies by \code{k}.
If FALSE, then \eqn{b_{ik}} is returned as a list object where each element of the list varies by \code{k}.}

\item{theta.names}{a list parameter names. It is nested by the value of \code{K}. This list object can be generated using \code{gen_theta_names(..., purpose = "bik")}. \cr
Because this function is often using within the \code{optim()} function, it is inefficient to generate the names every iteration via \code{paste()}, hence having this pre-generated will help with speed.}
}
\value{
A list object. Depending on input value for \code{P.rs}. \cr\cr
If \code{P.rs} is specified to be TRUE, then the transition probability from state \code{r} to state \code{s} within \code{dt} amount of time is return.
As such, each element of \code{P.rs} is the same length as the input argument \code{dt}. \cr
If \code{P.rs} is set to FALSE however, then the quantity \eqn{b_{ik}} is returned (see note section for more info)
}
\description{
Computes \eqn{b_{ik}} for \eqn{k \geq 2}. See \strong{Note} section for more info
}
\note{
This function computes the transition rates internally using the input arguments (\code{theta}, \code{Xmat}, \code{Wmat}).
Furthermore, this functions combines the \code{get_P} and the \code{Li} functions to obtain the quantities \eqn{P_{rs(k)}} or \eqn{b_{ik}}. \cr\cr
\eqn{P_{rs(k)}} is the transition probability from state \code{r} to state \code{s} within \code{dt} amount of time, condition on the latent variable \strong{Z}. If \eqn{\delta t = t_{2}-t_{1}} then,
\deqn{
  P_{rs(k)}(\delta t) = P(Y(t_2)=s | Y(t_1)=r \cap Z=k)
}
Similarly, \eqn{b_{ik}} is the following
\deqn{
  b_{ik} = \pi_{k} \cdot \prod_{j}{P_{rs(k)}(\delta t_{ij})}
}
where \eqn{r=y_{i(j-1)}} and \eqn{s=y_{ij}}
}
\examples{
# This is a 2x2 case example
# generate data
my_ids = c(1,1,1, 2,2, 3,3,3)
c1 = c(0,1,1.5, 0,1, 0,2,5)
c2 = c(1,2,2, 1,1, 2,1,2)
x1 = c(rep(rnorm(n = 1), 3), rep(rnorm(n = 1), 2), rep(rnorm(n = 1), 3))
x2 = c(rep(1, 3), rep(0, 2), rep(1, 3))
w1 = c(rep(runif(n = 1), 3), rep(runif(n = 1), 2), rep(runif(n = 1), 3))
w2 = c(rep(0, 3), rep(0, 2), rep(1, 3))
latent_class = c(1,1,1, 1,1 ,2,2)

# create data frame and matrix objects
my_df = data.frame(
  id = my_ids,
  obsTime = c1, state_at_obsTime = c2,
  x1 = x1, x2 = x2,
  w1 = w1, w2 = w2
)

my_df2 = LCTMC:::fmt_rowwise_trans(data = my_df, type = "2x2")
xmat = as.matrix(my_df2[c("x0", "x1", "x2")])
wmat = unique(my_df2[c("id", "w0", "w1", "w2")])
wmat = as.matrix(wmat[!colnames(wmat) \%in\% c("id")])

# - # - # - # - # - # - # - # - # -

# create theta vector ~ case of 2 latent classes
my_theta = c("alpha0.1" = 1.0, "alpha1.1" = 1.0, "alpha2.1" = 1.0,
             "beta0.12_1" = 1.1, "beta1.12_1" = 1.1, "beta2.12_1" = 1.1,
             "beta0.21_1" = 1.5, "beta1.21_1" = 1.5, "beta2.21_1" = 1.5,
             "beta0.12_2" = 1.8, "beta1.12_2" = 1.8, "beta2.12_2" = 1.8,
             "beta0.21_2" = 0.3, "beta1.21_2" = 0.3, "beta2.21_2" = 0.3)

# use bik_all_2x2() ~ case of 2 latent classes
LCTMC:::bik_all_2x2(
  theta = my_theta,
  data = my_df2,
  Xmat = xmat,
  Wmat = wmat,
  dt = my_df2$dt,
  K = 2L,
  P.rs = FALSE,
  theta.names = gen_theta_names(K = 2L, type = "2x2", purpose = "bik")
)

# - # - # - # - # - # - # - # - # -

# create theta vector ~ case of 3 latent classes
my_theta = c("alpha0.1" = 1.0, "alpha1.1" = 1.0, "alpha2.1" = 1.0,
             "alpha0.2" = 0.5, "alpha1.2" = 0.2, "alpha2.2" = 0.2,
             "beta0.12_1" = 1.1, "beta1.12_1" = 1.1, "beta2.12_1" = 1.1,
             "beta0.21_1" = 1.5, "beta1.21_1" = 1.5, "beta2.21_1" = 1.5,
             "beta0.12_2" = 1.8, "beta1.12_2" = 1.8, "beta2.12_2" = 1.8,
             "beta0.21_2" = 0.3, "beta1.21_2" = 0.3, "beta2.21_2" = 0.3,
             "beta0.12_3" = 1.4, "beta1.12_3" = 1.4, "beta2.12_3" = 1.4,
             "beta0.21_3" = 0.4, "beta1.21_3" = 0.4, "beta2.21_3" = 0.4)

# use bik_all_2x2() ~ case of 3 latent classes
LCTMC:::bik_all_2x2(
  theta = my_theta,
  data = my_df2,
  Xmat = xmat,
  Wmat = wmat,
  dt = my_df2$dt,
  K = 3L,
  P.rs = FALSE,
  theta.names = gen_theta_names(K = 3L, type = "2x2", purpose = "bik")
)

# - # - # - # - # - # - # - # - # -

# create theta vector ~ case of 4 latent classes
my_theta = c("alpha0.1" = 1.0, "alpha1.1" = 1.0, "alpha2.1" = 1.0,
             "alpha0.2" = 0.5, "alpha1.2" = 0.2, "alpha2.2" = 0.2,
             "alpha0.3" = -0.5, "alpha1.3" = -1.0, "alpha2.3" = -0.2,
             "beta0.12_1" = 1.1, "beta1.12_1" = 1.1, "beta2.12_1" = 1.1,
             "beta0.21_1" = 1.5, "beta1.21_1" = 1.5, "beta2.21_1" = 1.5,
             "beta0.12_2" = 1.8, "beta1.12_2" = 1.8, "beta2.12_2" = 1.8,
             "beta0.21_2" = 0.3, "beta1.21_2" = 0.3, "beta2.21_2" = 0.3,
             "beta0.12_3" = 1.4, "beta1.12_3" = 1.4, "beta2.12_3" = 1.4,
             "beta0.21_3" = 0.4, "beta1.21_3" = 0.4, "beta2.21_3" = 0.4,
             "beta0.12_4" = 0.9, "beta1.12_4" = 0.9, "beta2.12_4" = 0.9,
             "beta0.21_4" = 0.8, "beta1.21_4" = 0.8, "beta2.21_4" = 0.8)

# use bik_all_2x2() ~ case of 4 latent classes
LCTMC:::bik_all_2x2(
  theta = my_theta,
  data = my_df2,
  Xmat = xmat,
  Wmat = wmat,
  dt = my_df2$dt,
  K = 4L,
  P.rs = FALSE,
  theta.names = gen_theta_names(K = 4L, type = "2x2", purpose = "bik")
)
}
\seealso{
\code{\link[=get_P_2x2]{get_P_2x2()}}; \code{\link[=Li_2x2]{Li_2x2()}}; \code{\link[=fmt_rowwise_trans]{fmt_rowwise_trans()}}, \code{\link[=gen_theta_names]{gen_theta_names()}}; \code{\link[=impute_bik]{impute_bik()}}
}
